import uuid
from django.db import models


class Metadata(models.Model):
    """Metadata collection tracking all user databases and collections."""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user_id = models.UUIDField()  # User reference
    number_of_databases = models.IntegerField(default=0)
    number_of_collections = models.IntegerField(default=0)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    databases = models.JSONField(default=list)  # List of databases
    collections = models.JSONField(default=list)  # List of collections

    def __str__(self):
        return f"Metadata for User {self.user_id}"

    def to_dict(self):
        return {
            "id": self.id,
            "user_id": self.user_id,
            "number_of_databases": self.number_of_databases,
            "number_of_collections": self.number_of_collections,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
            "databases": self.databases,
            "collections": self.collections,
        }

    def add_database(self, database_name):
        """Add a new database entry to metadata."""
        new_db = {
            "id": str(uuid.uuid4()),
            "name": database_name,
            "number_of_collections": 0,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
            "last_accessed": self.updated_at
        }
        self.databases.append(new_db)
        self.number_of_databases += 1
        self.save()

    def remove_database(self, database_id):
        """Remove a database entry from metadata."""
        self.databases = [db for db in self.databases if db["id"] != database_id]
        self.number_of_databases -= 1
        self.save()

    def add_collection(self, database_id, collection_name):
        """Add a collection to a database."""
        new_collection = {
            "id": str(uuid.uuid4()),
            "name": collection_name,
            "database_id": database_id,
            "number_of_fields": 0,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
            "last_accessed": self.updated_at,
            "fields": []
        }
        self.collections.append(new_collection)
        self.number_of_collections += 1

        # Update corresponding database entry
        for db in self.databases:
            if db["id"] == database_id:
                db["number_of_collections"] += 1
                db["updated_at"] = self.updated_at
                break

        self.save()

    def remove_collection(self, collection_id):
        """Remove a collection from metadata."""
        self.collections = [col for col in self.collections if col["id"] != collection_id]
        self.number_of_collections -= 1
        self.save()

    def add_field(self, collection_id, field_name, field_type, required=False, unique=False, options=None):
        """Add a field to a collection."""
        options = options or []
        new_field = {
            "id": str(uuid.uuid4()),
            "name": field_name,
            "type": field_type,
            "required": required,
            "unique": unique,
            "options": options,
            "soft_deleted": False,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
            "last_accessed": self.updated_at
        }

        for col in self.collections:
            if col["id"] == collection_id:
                col["fields"].append(new_field)
                col["number_of_fields"] += 1
                col["updated_at"] = self.updated_at
                break

        self.save()

    def remove_field(self, collection_id, field_id):
        """Remove a field from a collection."""
        for col in self.collections:
            if col["id"] == collection_id:
                col["fields"] = [field for field in col["fields"] if field["id"] != field_id]
                col["number_of_fields"] -= 1
                col["updated_at"] = self.updated_at
                break

        self.save()

    def get_database_by_id(self, database_id):
        """Retrieve a database by ID."""
        for db in self.databases:
            if db["id"] == database_id:
                return db
        return None

    def get_collection_by_id(self, collection_id):
        """Retrieve a collection by ID."""
        for col in self.collections:
            if col["id"] == collection_id:
                return col
        return None

    def get_metadata_by_user_id(self, user_id):
        """Retrieve metadata for a specific user."""
        return Metadata.objects.filter(user_id=user_id).first()







# # models.py
# from django.db import models
# from django.contrib.postgres.fields import JSONField
# from django.contrib.auth.models import User
# from django.utils import timezone
# from django.forms.models import model_to_dict
# import uuid
# import json
# from django.contrib.auth.hashers import make_password

# class DatabaseMetadata(models.Model):
#     """Metadata for a database."""
#     id = models.CharField(max_length=24, primary_key=True, default=lambda: str(uuid.uuid4()))
#     database_name = models.CharField(max_length=100, unique=True)
#     created_at = models.DateTimeField(auto_now_add=True)
#     last_updated = models.DateTimeField(auto_now=True)
#     owner = models.ForeignKey(User, on_delete=models.CASCADE, related_name='databases')

#     def __str__(self) -> str:
#         """Return string representation of DatabaseMetadata."""
#         return str(self.database_name)

#     class Meta:
#         indexes = [
#             models.Index(fields=['created_at']),
#             models.Index(fields=['last_updated']),
#         ]

#     def to_dict(self):
#         """Return a dictionary representation of the DatabaseMetadata."""
#         return model_to_dict(self)


# class APIKey(models.Model):
#     """API Key for a database."""
#     id = models.CharField(max_length=24, primary_key=True, default=lambda: str(uuid.uuid4()))
#     user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="api_keys")
#     hashed_key = models.CharField(max_length=255, blank=True, null=True)
#     expires_at = models.DateTimeField(null=True, blank=True)
#     created_at = models.DateTimeField(auto_now_add=True)
#     last_used = models.DateTimeField(null=True, blank=True, default=timezone.now,)
#     is_active = models.BooleanField(default=True)
#     permissions = JSONField(default=list, blank=True, null=True)

#     def save(self, *args, **kwargs):
#         if self.hashed_key is None and self.key is not None:  # ensure that key is hashed
#             self.hashed_key = make_password(self.key)
#             self.key = None  # remove the plain text key
#         super(APIKey, self).save(*args, **kwargs)

#     def __str__(self) -> str:
#         """Return string representation of APIKey."""
#         return str(f"API Key for user {self.user.username}")

#     def check_permissions(self, database, collection=None, method=None):
#         """Check if API key has permission for the given database, collection, and method."""
#         if not self.is_active or not self.permissions:
#             return False
        
#         for permission in self.permissions:
#             if permission.get('database') == 'all':
#                 if collection is None and method is None:
#                     return True
#                 elif collection is None and method in permission.get('methods', []):
#                     return True
#                 elif collection in permission.get('collection') and method in permission.get('methods', []):
#                     return True
#             else:
#                 if database.id in permission.get('database') and collection is None and method is None:
#                     return True
#                 elif database.id in permission.get('database') and collection is None and method in permission.get('methods', []):
#                     return True
#                 elif database.id in permission.get('database') and collection in permission.get('collection') and method in permission.get('methods', []):
#                     return True # permission granted
            
#         return False # permission not granted

#     def get_permissions(self):
#         """Get the permissions for the API key."""
#         return self.permissions

#     def set_permissions(self, permissions):
#         """Set the permissions for the API key."""
#         self.permissions = permissions

#     @property
#     def key(self):
#         """Return the API key."""
#         if self.hashed_key:
#             return make_password(self.hashed_key)
#         return None


# class CollectionMetadata(models.Model):
#     """Metadata for collections in a database."""
#     id = models.CharField(max_length=24, primary_key=True, default=lambda: str(uuid.uuid4()))
#     database = models.ForeignKey(DatabaseMetadata, on_delete=models.CASCADE, related_name='collections')
#     name = models.CharField(max_length=100)
#     fields = JSONField(default=list, blank=True, null=True)
#     total_documents = models.IntegerField(default=0)
#     created_at = models.DateTimeField(auto_now_add=True)
#     last_updated = models.DateTimeField(auto_now=True)

#     class Meta:
#         unique_together = ('database', 'name')

#     def __str__(self) -> str:
#         """Return string representation of CollectionMetadata."""
#         return str(f"{self.database.database_name} - {self.name}")

#     def to_dict(self):
#         """Return a dictionary representation of the CollectionMetadata."""
#         return { "fields": [field.to_dict() for field in self.fields] }

#     def add_field(self, field):
#         """Add a field to the collection."""
#         self.fields.append(field)

#     def get_field(self, field_name):
#         """Get a field by its name."""
#         for field in self.fields:
#             if field['name'] == field_name:
#                 return field
#         return None

#     def update_field(self, field_name, field):
#         """Update a field by its name."""
#         field_to_update = self.get_field(field_name)
#         if field_to_update:
#             for key, value in field.items():
#                 field_to_update[key] = value
#         else:
#             raise ValueError("Field does not exist")

#     def delete_field(self, field_name):
#         """Delete a field by its name."""
#         self.fields = [field for field in self.fields if field['name'] != field_name]


# class Field(models.Model):
#     """Field metadata"""
#     collection = models.ForeignKey(CollectionMetadata, on_delete=models.CASCADE, related_name='fields')
#     name = models.CharField(max_length=100)
#     type = models.CharField(max_length=100)
#     required = models.BooleanField(default=False)
#     unique = models.BooleanField(default=False)
#     options = JSONField(default=list, blank=True, null=True)
#     soft_deleted = models.BooleanField(default=False)
#     created_at = models.DateTimeField(auto_now_add=True)
#     last_updated = models.DateTimeField(auto_now=True)

#     class Meta:
#         unique_together = ('collection', 'name')

#     def __str__(self) -> str:
#         """Return string representation of Field."""
#         return str(f"Field {self.name} in {self.collection.name}")

#     def to_dict(self):
#         """Return a dictionary representation of the Field."""
#         return model_to_dict(self)

#     def update(self, data):
#         """Update the field."""
#         self.name = data['name']
#         self.type = data['type']
#         self.required = data['required']
#         self.unique = data['unique']
#         self.options = data.get('options', [])  # set default option to []
#         self.soft_deleted = data.get('soft_deleted', False)
#         self.save()

#     def delete(self):
#         """Delete the field."""
#         self.collection.fields.remove(self)


# class UserMetadata(models.Model):
#     """Metadata for a user."""
#     user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='metadata')
#     api_keys = models.ManyToManyField(APIKey, related_name='user')
#     database_metadata = models.ManyToManyField(DatabaseMetadata, related_name='users')
#     collection_metadata = models.ManyToManyField(CollectionMetadata, related_name='users')
#     fields = models.ManyToManyField(Field, related_name='users')

#     def __str__(self) -> str:
#         """Return string representation of UserMetadata."""
#         return str(self.user.username)

#     def to_dict(self):
#         """Return a dictionary representation of the UserMetadata."""
#         return model_to_dict(self)


# class UserProfile(models.Model):
#     """Profile information for the user"""
#     user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
#     first_name = models.CharField(max_length=255, blank=True)
#     last_name = models.CharField(max_length=255, blank=True)


# @receiver(UserMetadata.save)
# def update_user_metadata(sender, instance, **kwargs):
#     """Update related metadata when user metadata is saved."""
#     for api_key in instance.api_keys.all():
#         api_key.refresh_from_db()
#     for database in instance.database_metadata.all():
#         database.refresh_from_db()
#     for collection in instance.collection_metadata.all():
#         collection.refresh_from_db()
#     for field in instance.fields.all():
#         field.refresh_from_db()


# @receiver(UserMetadata.delete)
# def delete_user_metadata(sender, instance, **kwargs):
#     """Delete related metadata when user metadata is deleted."""
#     for api_key in instance.api_keys.all():
#         api_key.delete()
#     for database in instance.database_metadata.all():
#         database.delete()
#     for collection in instance.collection_metadata.all():
#         collection.delete()
#     for field in instance.fields.all():
#         field.delete()